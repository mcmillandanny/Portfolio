{"version":3,"sources":["GodrayFilter.js"],"names":["PIXI","GodrayFilter","options","vertex","fragment","replace","perlin","uniforms","dimensions","Float32Array","console","warn","angle","arguments","undefined","gain","lacunarity","time","Object","assign","parallel","center","_angleLight","Point","filterManager","input","output","clear","sourceFrame","width","height","light","aspect","applyFilter","_angle","value","radians","DEG_TO_RAD","x","Math","cos","y","sin","Filter"],"mappings":"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","file":"GodrayFilter.js","sourcesContent":["import {vertex} from '@tools/fragments';\nimport perlin from './perlin.frag';\nimport fragment from './gorday.frag';\nimport * as PIXI from 'pixi.js';\n\n/**\n* GordayFilter, {@link https://codepen.io/alaingalvan originally} by Alain Galvan\n*\n*\n*\n* ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/godray.gif)\n* @class\n* @extends PIXI.Filter\n* @memberof PIXI.filters\n*\n* @example\n*  displayObject.filters = [new GodrayFilter()];\n* @param {object} [options] Filter options\n* @param {number} [options.angle=30] Angle/Light-source of the rays.\n* @param {number} [options.gain=0.5] General intensity of the effect.\n* @param {number} [options.lacunrity=2.5] The density of the fractal noise.\n* @param {boolean} [options.parallel=true] `true` to use `angle`, `false` to use `center`\n* @param {number} [options.time=0] The current time position.\n* @param {PIXI.Point|number[]} [options.center=[0,0]] Focal point for non-parallel rays,\n*        to use this `parallel` must be set to `false`.\n*/\nexport default class GodrayFilter extends PIXI.Filter {\n\n    constructor(options) {\n        super(vertex, fragment.replace('${perlin}', perlin));\n\n        this.uniforms.dimensions = new Float32Array(2);\n\n        // Fallback support for ctor: (angle, gain, lacunarity, time)\n        if (typeof options === 'number') {\n            // eslint-disable-next-line no-console\n            console.warn('GodrayFilter now uses options instead of (angle, gain, lacunarity, time)');\n            options = { angle: options };\n            if (arguments[1] !== undefined) {\n                options.gain = arguments[1];\n            }\n            if (arguments[2] !== undefined) {\n                options.lacunarity = arguments[2];\n            }\n            if (arguments[3] !== undefined) {\n                options.time = arguments[3];\n            }\n        }\n\n        options = Object.assign({\n            angle: 30,\n            gain: 0.5,\n            lacunarity: 2.5,\n            time: 0,\n            parallel: true,\n            center: [0, 0],\n        }, options);\n\n        this._angleLight = new PIXI.Point();\n        this.angle = options.angle;\n        this.gain = options.gain;\n        this.lacunarity = options.lacunarity;\n\n        /**\n         * `true` if light rays are parallel (uses angle),\n         * `false` to use the focal `center` point\n         *\n         * @member {boolean}\n         * @default true\n         */\n        this.parallel = options.parallel;\n\n        /**\n         * The position of the emitting point for light rays\n         * only used if `parallel` is set to `false`.\n         *\n         * @member {PIXI.Point|number[]}\n         * @default [0, 0]\n         */\n        this.center = options.center;\n\n        /**\n         * The current time.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.time = options.time;\n    }\n\n    /**\n     * Applies the filter.\n     * @private\n     * @param {PIXI.FilterManager} filterManager - The manager.\n     * @param {PIXI.RenderTarget} input - The input target.\n     * @param {PIXI.RenderTarget} output - The output target.\n     */\n    apply(filterManager, input, output, clear) {\n        const {width, height} = input.sourceFrame;\n\n        this.uniforms.light = this.parallel ? this._angleLight : this.center;\n\n        this.uniforms.parallel = this.parallel;\n        this.uniforms.dimensions[0] = width;\n        this.uniforms.dimensions[1] = height;\n        this.uniforms.aspect = height / width;\n        this.uniforms.time = this.time;\n\n        // draw the filter...\n        filterManager.applyFilter(this, input, output, clear);\n    }\n\n    /**\n     * The angle/light-source of the rays in degrees. For instance, a value of 0 is vertical rays,\n     *     values of 90 or -90 produce horizontal rays.\n     * @member {number}\n     * @default 30\n     */\n    get angle() {\n        return this._angle;\n    }\n    set angle(value) {\n        this._angle = value;\n\n        const radians = value * PIXI.DEG_TO_RAD;\n\n        this._angleLight.x = Math.cos(radians);\n        this._angleLight.y = Math.sin(radians);\n    }\n\n    /**\n     * General intensity of the effect. A value closer to 1 will produce a more intense effect,\n     * where a value closer to 0 will produce a subtler effect.\n     *\n     * @member {number}\n     * @default 0.5\n     */\n    get gain() {\n        return this.uniforms.gain;\n    }\n    set gain(value) {\n        this.uniforms.gain = value;\n    }\n\n    /**\n     * The density of the fractal noise. A higher amount produces more rays and a smaller amound\n     * produces fewer waves.\n     *\n     * @member {number}\n     * @default 2.5\n     */\n    get lacunarity() {\n        return this.uniforms.lacunarity;\n    }\n    set lacunarity(value) {\n        this.uniforms.lacunarity = value;\n    }\n}\n\n"]}